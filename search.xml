<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于 Raspberry Pi+OpenCV+Arduino 的智能小车</title>
      <link href="/2022/03/03/%E5%9F%BA%E4%BA%8E%20Raspberry%20Pi+OpenCV+Arduino%20%E7%9A%84%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"/>
      <url>/2022/03/03/%E5%9F%BA%E4%BA%8E%20Raspberry%20Pi+OpenCV+Arduino%20%E7%9A%84%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<p>本项目基于上位机Raspberry Pi和下位机Arduino相互通信的环境，利用SSH远程登录，结合摄像头OpenCV和<br>Python进行图像的传输并判别交通信号的箭头，小车识别到绿色箭头朝箭头指示方向转弯，识别到红色箭头则<br>停在原地，并计算左右两侧的 PWM 值实现直线行驶，利用超声波模块检测小车前方障碍物距离实现避障。<br>    <img src="/source/images/cv2.png"></p><h2 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h2><pre class=" language-bash"><code class="language-bash">    本项目有两个控制板块，树莓派作为上位机，Arduino作为下位机，超声波模块用于检测前方一定距离内是否有箭头标志阻挡前进的路线，电机驱动模块以PWM方式控制左右两侧的轮子（左边两个轮子相同速度信号，右边两个轮子相同速度信号），通过左右车轮的速度差来达到转弯的效果。    树莓派作为上位机，通过摄像头判别交通箭头的信号。判别箭头是通过判断识别到的轮廓（箭头轮廓）的重心和最小外接矩形的重心两者的位置，箭头的朝向跟箭头重心的位置直接关联，所以可以根据两个重心的位置关系来判断箭头是左箭头还是右箭头。关于颜色的识别，将RGB颜色转化位HSV空间的颜色，判断图片中的颜色是否在绿色或者红色的色域中，在色域中则说明是对应的颜色。</code></pre><pre><code>![](source/images/cv.png)</code></pre><h2 id="制作方案"><a href="#制作方案" class="headerlink" title="制作方案"></a>制作方案</h2><h3 id="环境的安装"><a href="#环境的安装" class="headerlink" title="环境的安装"></a>环境的安装</h3><p>主要涉及关于树莓派和OpenCV的安装<br>·1 树莓派安装（便于可视化可以配置一台显示屏，但意义就没有了，因此获取树莓派IP后可以通过SSH远程控制树莓派）<br>    1.1 下载系统镜像（之前写过关于<a href="https://blog.csdn.net/qq_43451257/article/details/105060324?spm=1001.2014.3001.5502">Ubuntu16.04下Git的安装</a>）,此处使用的是Raspbian的镜像（自带桌面和一些软件）<br>    1.2 格式化SD卡，将镜像写入，完成系统的安装<br>    1.3 开启SSH<br>        首先在根目录下新建SSH文件，用于远程登录，然后就把SD卡插到树莓派上；<br>        第一次需要用网线连接树莓派和电脑，使其处于同一网段下，然后通过PuTTY配置 IP地址：raspberrypi.local 端口：22；<br>        连接成功后输入登录名pi和密码raspberry,接下来简单配置并连接与电脑相同的WiFi；<br>        可下载一个VNC Viewer用于连接到树莓派的桌面。</p><p>·2 OpenCV安装<br>    安装并编译OpenCV的资源库<br>    接下来都要在cv的环境中操作</p><h3 id="硬件的连接"><a href="#硬件的连接" class="headerlink" title="硬件的连接"></a>硬件的连接</h3><p><strong>主要器材：</strong><br>航模电池：给Arduino和电机驱动模块供电；<br>降压模块：用于降压保护Arduino和电机，并可以稳定电压；<br>电机驱动模块（L298N）：给电机供电，左侧两个电机的正极同时连接电机驱动模块上的一个out3，负极连接到out4，右侧连接out1、out2；<br>超声波模块：直接接在Arduino板块上，由Arduino供电并且由Arduino读取返回的信号值，即反馈小车当前的位置状态。</p><p>Step1. 将树莓派与Arduino通过USB线（通用串行总线）建立连接。【Arduino在树莓派中是靠串口连接通信的，有<a href="https://www.cnblogs.com/jingxinbk/p/12408886.html">两种</a>：USB连接和GPIO通信(其中树莓派的RX引脚——Arduino的TX引脚，树莓派的TX引脚——Arduino的RX引脚，树莓派的GND引脚——Arduino的GND引脚)】<br>Step2. 在树莓派终端输入ls &#x2F;dev&#x2F;tty*查看两者连接端口的名字，若是出现ttyACM0则二者成功建立通信。<br>Step3. 编写树莓派与Arduino之间通信的代码</p><pre><code>树莓派端：</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">import</span> serial    ser <span class="token operator">=</span> serial.Serial<span class="token punctuation">(</span><span class="token string">'/dev/ttyACM0'</span>, 9600,timeout<span class="token operator">=</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># AMA0（外部晶振驱动）较mini（自带晶振驱动）串口稳定性高</span>try:  <span class="token keyword">while</span> 1:    ser.write<span class="token punctuation">(</span><span class="token string">'s'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># 树莓派通过串口发送字符's'</span>    response <span class="token operator">=</span> ser.readall<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># 读取串口的返回值</span>    print response<span class="token punctuation">;</span>except:  ser.close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># 抛出异常后关闭</span></code></pre><pre><code>Arduino端：【注意：将程序烧到Arduino后一定要把USB拔掉插到树莓派上，不然会导致串口占用！！！】</code></pre><pre class=" language-bash"><code class="language-bash">void setup<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>  Serial.begin<span class="token punctuation">(</span>9600<span class="token punctuation">)</span><span class="token punctuation">;</span> // 波特率9600 bps<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>void loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> Serial.available<span class="token punctuation">(</span><span class="token punctuation">))</span>  <span class="token comment" spellcheck="true"># 判断串口缓存区是否有数据</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>      if<span class="token punctuation">(</span><span class="token string">'s'</span> <span class="token operator">==</span> Serial.read<span class="token punctuation">(</span><span class="token punctuation">))</span>        Serial.println<span class="token punctuation">(</span><span class="token string">"Hello Raspberry,I am Arduino."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># Arduino收到字符's'后，就向串口打印"Hello Raspberry,I am Arduino."</span>     <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;   </span></code></pre><p><img src="/source/images/cv1.png" alt="硬件连接图"></p><h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><p>RGB模型：<br>HSV模型：色调（H:hue），饱和度（S:saturation），亮度（V:value）</p><p>So, 为什么要采用HSV空间的色域</p><p>Step1. 获得红色掩膜（进行按位或运算1|1&#x3D;1，1|0&#x3D;0，0|1&#x3D;0，0|0&#x3D;0）<br>       获得绿色掩膜<br>Step2. 中值滤波处理（平滑图像，滤去噪声,保护图像的边缘）<br>Step3. 寻找轮廓并计算重心 cv2.findContours()</p><h4 id="上位机代码"><a href="#上位机代码" class="headerlink" title="上位机代码"></a>上位机代码</h4><pre class=" language-bash"><code class="language-bash"></code></pre><h4 id="下位机代码"><a href="#下位机代码" class="headerlink" title="下位机代码"></a>下位机代码</h4><pre class=" language-bash"><code class="language-bash">上位机</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
